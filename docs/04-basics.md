# Basic container administration

This fourth part of our Docker guide gives an overview of some of the most frequently used commands when managing Docker containers.

## Outline

 - [Basic commands](#basic-commands)
 - [A closer look at `docker run`](#a-closer-look-at-docker-run)
 - [More on `docker ps`](#more-on-docker-ps)
 - [Using `docker inspect` effectively](#using-docker-inspect-effectively)
 - [Examining container logs](#examining-container-logs)

<br/>

## Basic commands

At the beginning, we want to do a high-level journey through the most basic Docker commands. Most of the following commands come with several options to tweak their behavior in different ways. We will look at them more closely in the next paragraphs.

<br/>

### The `docker run` command

The `docker run` command certainly belongs to the most important commands when it comes to managing the life cycle of a container. Its purpose is to start a process in a container, using an _image_ as a template:  

```
$ docker run hello-world
```

The general structure of the `docker run` command is defined as follows: <br/>

```
$ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]
```

 - __IMAGE__: Denotes the Docker image the container is based on. If _IMAGE_ is not present on disk, it first gets "pulled" (i.e. downloaded) from an image registry (default is Docker Hub).

 - __COMMAND__ (optional): This parameter defines the executable to be launched on container startup. It is not mandatory as images usually specify a default command. If specified, _COMMAND_ takes precedence over the defaults so they can be overridden if necessary.  

 - __[ARG...]__ (optional): A list of _n_ arguments (with n >= 0) that shall be passed to _COMMAND_.

 - __[TAG]__ (optional): Points to a certain version of an _IMAGE_, defaults to _latest_.
 - __[DIGEST]__ (optional): Provides another possbility to specify a certain image version by appending its hash (SHA-256) to the image name.  

 - __[OPTIONS]__ (optional): A list of options to modify the behavior of the `docker run` command.


We will examine these parameters in more detail and see them in action below.

<br/>

### The `docker ps` command

One of the most important aspects when running Docker containers is to keep an overview of all containers which are currently running. This is the purpose of the `docker ps` command, which returns a list of active containers by default. You can check it out yourself by launching the following commands in your terminal:

```
$ docker run -d dev4cloud/nightcap
$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
29c16ee80f01        dev4cloud/nightcap              "sleep 100"         2 seconds ago       Up 1 second                             happy_payne
```

You see that `docker ps` supplies some basic information most of which should be self-explanatory. As soon as the `sleep` process terminates or gets stopped explicitly the container is no longer visible in the list.
<br/>The general form of the command looks as follows:

```
$ docker ps [OPTIONS]
```

Again, this Docker command allows its behavior to be tweaked by a range of options some of which we will meet later.

<br/>

### The `docker inspect` command

While the `docker ps` command gives us a high-level overview of running containers, we can use the `docker inspect` command to get a more detailed insight into a specific container. To specify the container you want to examine, use its container ID or the random name it gets assigned by the Docker Engine (we'll see how to name containers in a custom fashion shortly).

```
$ docker inspect happy_payne
[
    {
        "Id": "29c16ee80f01f954d1879a1939794e3dc8101ef213e21b3cad817f18897a1e7d",
        "Created": "2017-12-08T14:17:43.508158352Z",
        "Path": "sleep",
        "Args": [
            "100"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 8839,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2017-12-08T14:17:43.913842045Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
 ...            
```  

The `docker inspect` command is generally used as follows:

```
docker inspect [OPTIONS] NAME|ID [NAME|ID...]
```

 - __NAME__: The name of the container to inspect (either randomly generated by Docker Engine or explicitly defined by user, must be unique).

 - __ID__: The UUID of a container which can likewise be used instead of the name to point to a certain container.

 - __[OPTIONS]__ (optional): Options to further adjust the commands behavior.  

Note that more than one container can be passed to the `docker inspect` command, as it optionally takes more than one _NAME_ or _ID_ as its arguments.  


<br/>


### The `docker logs` command

The `docker logs` command allows to access the logs of e.g. a containerized application that writes its traces to STDOUT and STDERR. For instance, this might be useful for debugging error conditions.  

```
$ docker run -d dev4cloud/hello-docker
2469992cf909ce37fe0f88d9f18ffbfb5fd9b14ed6862d21bb84f94a18cdea9a
$ docker logs 246999
Hello Docker!
```

The command's general structure looks like this:

```
docker logs [OPTIONS] NAME|ID
```

 - __NAME__: Randomly generated or user-defined unique name of container (see above).

 - __ID__: UUID of a container (see above).

 - __[OPTIONS]__ (optional): Options to further adjust the commands behavior.  


<br/>


## A closer look at `docker run`

Above, we've already introduced the purpose and syntax of the `docker run` command, which is used to create and launch containers from images. This subsection places the focus on some of the command's most relevant options and their use case.   

#### Assigning custom names to containers

First, let's see how we can assign custom names to containers so we can address them by means of meaningful designations. For that purpose, we use the `--name` option:

```
$ docker run -d --name nightcap dev4cloud/nightcap
50a7bf6c4dc93c760da50540ed43e8c49cff746eb454de88ab37614af72f618f
$ docker ps
CONTAINER ID        IMAGE                           COMMAND             CREATED             STATUS              PORTS               NAMES
50a7bf6c4dc9        dev4cloud/nightcap              "sleep 100"         3 seconds ago       Up 2 seconds                            nightcap

```

Custom names give us the opportunity to conveniently refer to specific containers in the context of other Docker commands without having to remember complicated container IDs. For example, we can inspect the container we previously launched by passing its name to the corresponding command:

```
$ docker inspect nightcap
```  

Note that container names must be unique. Consequently, the Docker daemon returns an error given that a container with a certain name already exists:

```
$ docker run -d --name nightcap dev4cloud/nightcap
50a7bf6c4dc93c760da50540ed43e8c49cff746eb454de88ab37614af72f618f
$ docker run -d --name nightcap dev4cloud/nightcap
docker: Error response from daemon: Conflict. The container name "/nightcap" is already in use by container "50a7bf6c4dc93c760da50540ed43e8c49cff746eb454de88ab37614af72f618f". You have to remove (or rename) that container to be able to reuse that name.
```

<br/>


#### Specifying a custom command   

As already mentioned, users can provide an executable that shall be launched when a Docker container gets started. The user-defined command takes precedence over an image's default process.
Paste the following Docker command into your terminal and give it a whirl:

```
$ docker run dev4cloud/hello-docker echo "Hello World!"
Hello World!
```

Here, we instruct our sample image to print "Hello World!" instead of "Hello Docker!" which is its standard behavior if nothing else is specified.

In some cases, we'll have to use the `--entrypoint` option to specify the executable that shall be launched in the container. The section about Dockerfiles will examine this further.    

<br/>


#### Foreground mode and interactive containers

By default, Docker starts containers in _foreground mode_, meaning that the current console is attached to STDOUT and STDERR if not specified otherwise. You can observe this behavior by running the following container:

```
$ docker run -p 8080:80 nginx
```

Now go to your browser and fire some requests to `localhost:8080` where you should see a Nginx welcome page. At the same time, try to keep one eye on your console where some Nginx webserver logs should appear on incoming requests.

```
$ docker run -p 8080:80 nginx
172.17.0.1 - - [09/Dec/2017:17:09:27 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:57.0) Gecko/20100101 Firefox/57.0" "-"
```

In order to additionally attach the containerized process's STDIN to the terminal, we have to add the `--interactive` flag (short: `-i`):

```
$ echo "hi" | docker run -i dev4cloud/hello-docker cat
hi
```    

If we'd like to go one step further and run an interactive shell in a container, we additionally have to allocate a tty or [pseudo-terminal (tty)](https://en.wikipedia.org/wiki/Pseudoterminal) and attach it to our container. Docker can be instructed to do that for us via the `--tty` (short: `-t`) flag. Accordingly, the complete command to launch a containerized shell looks like this:

```
$ docker run -it alpine sh
/ # echo "Hello Docker!"
Hello Docker!
```

<br/>

#### Running containers in detached mode

#### Cleaning up containers automatically

<br/>

## More on `docker ps`

## Using `docker inspect` effectively

The output of the `docker inspect` command is slightly extensive and sometimes you're only interested in some defined part of the information it provides, e.g. its hostname. One option is to use `grep` in order to filter for the information you need:

```
$ docker inspect happy_payne | grep Hostname
"HostnamePath": "/var/lib/docker/containers/29c16ee80f01f954d1879a1939794e3dc8101ef213e21b3cad817f18897a1e7d/hostname",
    "Hostname": "29c16ee80f01",
```   

As you can see, using `grep` basically works but also might return additional "noisy" information we didn't search for, as `grep` does a simple string matching. Below, we'll examine how Go templates can be applied to be more precise with filtering without having to struggle with regular expressions.

## Examining container logs
